# OIDC Tests

## Description

This directory contains a test fixture and an IdP mock for testing authentication with OIDC.

## Table of Contents

1. [Suite Definition](#suite)
2. [Identity Provider Server Mock](#idp-server-mock)
3. [Identity Provider Mock](#idp-mock)
4. [Tests Fixture](#tests-fixture)
5. [Notes](#notes)

## Suite

The **OIDC** suite is defined in the [oidc.yml](../../../buildscripts/resmokeconfig/suites/oidc.yml) file.
A typical test starts the OIDC identity provider (IdP) mock and Percona Server
for MongoDB (as a standalone `mongod` or a sharded cluster) and then checks
various conditions. Both the IdP mock and Percona Server for MongoDB are started
via the test fixture. In all the tests except one, the network communication
between Percona Server for MongoDB and the IdP mock goes over plain HTTP. The
`mongodb_idp_https_conversation.js` test specifically checks the encrypted
communication using HTTPS.

The following command is an example of running all tests in this suite:

```sh
./buildscripts/resmoke.py --suite=oidc [<other_resmoke_options>]
```

## IdP Server Mock

### Usage

```text
usage: oidc_idp_mock.py [-h] [-v] --cert <path> [--config-json {<json>}] [issuer_url]

OIDC Identity Provider Mock

positional arguments:
  issuer_url            issuer URL [default: http://localhost:8080/issuer]

options:
  -h, --help            show this help message and exit
  -v, --verbose         enable verbose logging
  --cert <path>         certificate file for HTTPS, if provided, also requires
                        `issuer_url` with the HTTPS scheme
  --config-json {<json>}
                        configuration JSON
```

Additional configuration options can be provided via the `--config-json` argument, which expects a stringified **JSON** object.
The supported options for the configuration object are:

- `number_of_jwks: <int>` - the number of JWKs the mock should generate.
- `token: <token_config>` - access token configuration. If set to an object, an **infinite number** of tokens can be created with the given configuration. If set to an array, only the specified number of tokens will be created. See [token configuration](#token-configuration) for details.

See the [configuration example](#configuration-example) section for more details.

### Server Endpoints

Currently, the following endpoints are implemented:

- openid-configuration: `{issuer_url}/.well-known/openid-configuration` - for getting configuration,
- token_endpoint: `{issuer_url}/token` - for creating an access token and refresh token (always equal to 'refresh_token'),
- jwks_uri: `{issuer_url}/keys` - for getting the list of **JWKs**,
- device*authorization_endpoint: `{issuer_url}/device/authorize` - to simulate \_device authorization flow*,
- token*introspection: `{issuer_url}/introspect` - to simulate \_token introspection*.

### Token Configuration

- `expires_in_seconds`: token expiration time in seconds,
- `generate_jwks`: if set to `true', a new set of **JWKs** will be generated before creating the token,
- `jwt_id`: the index of the **JWT** key generated by the server; it must be less than `number_of_jwks`,
- `payload: <object>`: access token payload,
- `faults: <faults config>` - faults configuration. See the [fault injector](#fault-injector) section for details,
- `introspection: <introspection_config>` - introspection configuration. See [introspection](#introspection) for details.

  If the following fields are not defined, the following default values will be applied:

  - `iss`: set to the `<issuer_url>` provided in the command line options,
  - `iat`: set to the current time,
  - `exp`: set to the current time + `expires_in_seconds`.

  If set to `"$remove"`, they will not be defined in the token's payload.

Example configuration for an infinite number of tokens:

```js
{
    token: {
        payload: {
            sub: "user",
            aud: "audience",
            claim: [
                "group1",
                "group1",
            ]
        }
    }
}
```

Example configuration for two tokens with different parameters:

```js
{
  token: [
    {
      jwk_id: 0,
      payload: {
        sub: "user1",
        aud: "audience",
        claim: ["group1", "group2"],
      },
    },
    {
      jwk_id: 1,
      payload: {
        sub: "user2",
        aud: "audience",
        claim: ["group3"],
      },
    },
  ];
}
```

### Fault Injector

- `jwt_invalid_kid` - sets the `kid` field in the **JWT**'s header to `invalid`,
- `jwt_missing_kid` - omits the `kid` field in the **JWT**'s header,
- `jwt_invalid_key` - encodes the **JWT** with a private key not exposed via the `{issuer_url}/keys` endpoint,
- `jwt_other_valid_key` - encodes the **JWT** with another valid key exposed via the `{issuer_url}/keys` endpoint, different from the one specified in the `kid` field in the **JWT** header.

By default, no faults are applied.

Example:

```js
{
    token: {
        payload: {
            sub: "user",
            aud: "audience",
            claim: [
                "group1",
                "group2",
            ]
        },
        faults: {
            jwt_invalid_kid: false,
            jwt_missing_kid: false,
            jwt_invalid_key: false,
            jwt_other_valid_key: true,
        }
    },

}
```

### Introspection

The introspection configuration is used to simulate the introspection endpoint - `{issuer_url}/introspect`.

If the introspection configuration is not provided, an automatic introspection will be performed.
The automatic introspection:

- uses the same key as the one used to sign the token; this means that if the `jwt_invalid_key` or `jwt_other_valid_key` faults were applied, the introspection will succeed,
- does not validate the `kid` field in the header; this means that if the `jwt_invalid_kid` or `jwt_missing_kid` faults were applied, the introspection will succeed,
- validates the payload by comparing it with the payload used to sign the token,
- in case of an error, the introspection will return a `400` status code with the error message,
- in case of verification failure, the introspection will return a `200` status code with `active: false`,
- in case of success, the introspection will return a `200` status code with `active: true` and the payload used to sign the token.

The introspection configuration can be provided in two ways:

- as an object, which will be used for all introspections for a given token,
- as an array, which will be used for as many introspections as the size of the array; if more introspections are requested, an error will be returned.

The introspection configuration can contain arbitrary fields, which will be returned in the introspection response.

There are two special fields, which can be used to control the response:

- `$auto` - if set to `true`, the introspection will be performed automatically, as described above. The result can be overwritten by any other field provided in the configuration,
- `$status_code` - the HTTP status code to be returned; if not provided, the default value is `200`. If provided together with `$auto`, the status code of the automatic introspection will be overwritten.

If any field is set to `"$remove"`, it will be removed from the response.

#### Examples

If no introspection configuration is provided, the automatic introspection will be performed on every request:

```js
token: {
    payload: {
        (...)
    },
}
```

With the following configuration, an automatic introspection will be performed, the `custom_field` will be added to the introspection response, the status code will be `400`, and the `sub` field will be removed from the response:

```js
token: {
    payload: {
        (...)
    },
    introspection: {
        $auto: true,
        $status_code: 400,
        custom_field: "value",
        sub: "$remove",
    }
}
```

With the following configuration, no automatic introspection will be performed, the `error` field will be added to the introspection response, and the status code will be `400`:

```js
token: {
    payload: {
        (...)
    },
    introspection: {
        error: "error message",
        $status_code: 400,
    }
}
```

With the following configuration, the first introspection request will be performed automatically.
For the second request, the result will be `active: false` and the status code will be `200`.
Such a configuration can be used to simulate token revocation.

```js
token: {
    payload: {
        (...)
    },
    introspection: [
        {
            $auto: true
        },
        {
            active: false,
        }
    ]
}
```

### Configuration Example

With the following configuration, the **IdP Server Mock** will:

- create two JWKs,
- create a **maximum** of two tokens: the first for `user1`, the second for `user2`,
- the first token will be created with the first JWK,
- the second token will be created with the second JWK,
- the first token will expire in 2 seconds,
- the second token will expire in 3600 seconds,
- the second token will miss the `iss`, `iat`, and `exp` fields in the payload,
- every request for introspection of the second token will return `active: false` and the status code `200`.

```js
{
    number_of_jwks: 2,
    token: [
        {
            key_id: 0,
            expires_in_seconds: 2,
            payload: {
                aud: "audience",
                sub: "user1",
                claim: [
                    "group1",
                    "group2",
                ]
            }
        },
        {
            key_id: 1,
            payload: {
                iss: "$remove",
                iat: "$remove",
                exp: "$remove",
                aud: "audience",
                sub: "user2",
                claim: [
                    "group1",
                    "group2",
                ]
            },
            introspection: {
                active: false,
            }
        }
    ]
};
```

With the following configuration, the **IdP Server Mock** will create multiple tokens without a claim.

```js
{
    number_of_jwks: 2,
    token: {
        key_id: 0,
        expires_in_seconds: 2,
        payload: {
            aud: "audience",
            sub: "user1",
        }
    },
};
```

## IdP Mock

The `JavaScript` class represents an OIDC IdP Mock. It starts the [OIDC IdP Server Mock](#idp-server-mock) and provides helper functions for checking if appropriate requests were made against the server.

See the [oidc_idp_mock.js](./oidc_idp_mock.js) file for details.

## Tests Fixture

The `JavaScript` class represents a fixture for **OIDC** tests. It starts the `mongod` process and configures `OIDC IdP Mocks` with the given configuration.

It provides some helper functions for convenience.

See the [oidc_idp_mock.js](./oidc_idp_mock.js) file for details.

### Example Usage

The following example configures one `OIDC IdP Mock` and one _OIDC Provider_ for `mongod`.

It starts both the `OIDC IdP Mock` and `mongod` by calling the `setup()` function.

It authenticates the `user` with the **OIDC** mechanism, ensures the **OIDC** configuration was requested, and verifies that a token with the expected `client_id` and `scopes` was requested.

At the end, it ensures appropriate roles were assigned to the authenticated user.

The `teardown()` function stops both the `OIDC IdP Mock` and `mongod`.

```js
import {OIDCFixture} from "jstests/oidc/lib/oidc_fixture.js";

const idp_port = allocatePort();
const issuer_url = "https://localhost:" + idp_port + "/issuer";

var idp_config = {
  token: {
    expires_in_seconds: 3600,
    payload: {
      aud: "audience",
      sub: "user",
      claim: ["group1", "group2"],
    },
  },
};

var oidcProvider = {
  issuer: issuer_url,
  clientId: "clientId",
  audience: "audience",
  authNamePrefix: "test",
  useAuthorizationClaim: true,
  requestScopes: ["offline_access"],
  supportsHumanFlows: true,
  authorizationClaim: "claim",
};

var test = new OIDCFixture({
  oidcProviders: [oidcProvider],
  idps: [{url: issuer_url, config: idp_config}],
});
test.setup();
var conn = test.create_conn();
var idp = test.get_idp(issuer_url);

test.auth(conn, "user");
idp.assert_config_requested();
idp.assert_token_requested(oidcProvider.clientId, oidcProvider.requestScopes);
test.assert_authenticated(conn, "test/user", ["test/group1", "test/group2"]);
test.logout(conn);

test.teardown();
```

## Notes

### Authorization Flow

The `mongo` shell currently does not support the **Authorization Code Flow**. Therefore, all tests for OIDC authentication use the **Device Authorization Flow** instead. The [Identity Provider Server Mock](#idp-server-mock) implements the `/device/authorize` and `/device/verify` endpoints to support the `mongo` shell's requirements. However, the expected request fields are ignored, and the access token is returned based on the configuration provided for the [Identity Provider Server Mock](#idp-server-mock).
